## 排序

#### 概述

**数据排序**：将一个文件的记录按关键字不减（或不增）次序排列，使文件成为有序文件

**稳定排序**：排序后，相同关键字的记录保持它们原来的相对次序

**不稳定排序**：排序后，相同关键字的记录相对次序发生变更



**排序类型**

- 内部排序：全部数据存于内存
- 外部排序：需要对外存进行访问





比较算法的好坏，主要看空间复杂度和时间复杂度。通过代码来实现各种排序

定义数据结构体

```c
typedef struct {
    int key;  // 关键字项
    ItemType otherItem;  // 其他数据项
} RecordType;

typedef RecordType list[n+1];

// list R;  定义数据
// R[i].key 代表第 i 个记录的关键字 
```



#### 插入排序

##### 直接插入排序

稳定性：稳定排序

```c
void StraightInsertSort(list R, int n)
{	
    for (i = 2; i <= n; i++)
    {
        // R[0] 保存 R[i] 的值，第一是方便互换；
        // 第二是岗哨作用，相等后就跳出循环体，可以少写一个j为负数的判断
        R[0] = R[i];  
        j = j - 1;
        while (R[0].key < R[j])
        {
            R[j+1] = R[j];  // 记录后移
            j--;
        }
        R[j+1] = R[0];
    }
}
```



#### 交换排序

##### 冒泡排序

> 通过多次重复比较，交换相邻记录 

时间复杂度：O(n^2)

空间复杂度：O(1)

稳定性：稳定排序

```c
void BubbleSort(List R, int n)
{
    int i, j, temp, endSort;
    for (i = 1; i <= n - 1; i++)
    {
        endSort = 0;  // 若未记录交换，则说明已经有序
        for (j = 1; j <= n - i; j++)
        {
            if (R[j].key > R(j+1).key)
            {
                temp = R[j];
                R[j] = R[j+1];
                R[j+1] = temp;
                endSort = 1;
            }
        }
        if (endSort == 0) break;
    }
}
```



##### 快速排序

> 通过分部排序完成整个表的排序。首先取第一个记录，与表中其余记录比较并交换，使记录表左边的关键字均小于它，右边的关键字均大于它，然后对这两部分重新执行上述过程，直至排序完毕。

时间复杂度：O(log2n)



#### 选择排序

##### 直接选择排序





##### 堆排序





#### 归并排序

##### 有序序列的合并



##### 二路归并排序



