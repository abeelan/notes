



### 查找表



#### 基本概念

> 查找表：由同一类型的数据元素构成的**集合**
> 关键字：用来标识数据元素的数据项，简称**键**，其值称为**键值**
> **主关键字：可唯一标识各个数据元素的关键字**
> 查找：根据给定的某个 k 值，在查找表寻找一个其键值等于 k 的数据元素

静态查找表：进行的是**引用型**运算，操作为：建表、查找、读取表中元素。

动态查找表：进行的是**加工型**运算，操作为：初始化、查找、读表中元素、**插入**、**删除**



#### 静态查找表

静态查找表的实现：

- 顺序查找
- 有序表上的查找（二分查找）
- 索引表上的查找（分块查找）

##### 1. 顺序查找

> 首先，从表中**最后一个**记录开始**顺序**查找，若当前记录的关键字**等于**给定值，则**查找成功**；
>
> 否则，继续查找上一记录；
>
> 直至到第一个记录还未查找到，则**查找失败**。



```c
// 静态查找表长度
const int maxsize = 20;

// 定义数据结构体
typedef struct {
    keytype key;  // 关键字域
    ...  // 其他域
} TableElem;

typedef struct {
    // 定义一维数组，0 号元素留空
    TableElem elem[maxsize + 1];
    // 最后一个元素的下标，即表长
    int n;  
} SeqTable;
```



算法实现：使用一种设计技巧，设立岗哨 

```c
int SearchSeqTable(SeqTable T, KeyType key)
{
    // 将要查找的元素放到 0 的位置
    T.elem[0].key = key;
    i = T.n;  // 表长度
    
    // 从最后一个值开始查找，当前值不等于预期值时，i--，继续查找
    // 找到时返回下标，没有找到就返回 0
    // 0 是岗哨，就不用每次在循环内判断 i-- 是否小于 0，节省了一半的时间
    // 空间（T.elem[0]）换时间
    while (T.elem[i].key != key) i--;
    return i;
}
```

**算法分析**

- 成功查找：==ASL=(n+1)/2==，平均次数
- 不成功查找：==ASL=n+1==，n 个元素查找 n 次，再加上 0 号元素的那次

- 优点：简单，对表无要求

- 缺点：比较次数多，时间复杂度是 ==O(n)==



##### 2. 有序表上的查找 - 二分查找

> 关键点，每次找**中项**，可使下次查找范围缩小一半。
>
> 每次将处于查找区间中间位置的数据元素与给定值 K 进行比较，若不等则缩小查找区间，在新的区间内重复上述过程，直到查找成功或查找区间为 0（查找不成功）截止。
>
> **顺序方式存储，且元素按关键字有序**

算法实现

```c
int SearchBin (SeqTable T, KeyType k)
{
    int low, mid, high;
    low = 1;
    hign = T.n;
    while (low <= high)
    {
        mid = (low + high) / 2;
        if (key == T.elem[mid].key)
            return mid;
        else if (key < T.elem[mid].key) 
            high = mid - 1;
        else 
            low = mid + 1;
    }
    return 0;
}
```

**算法分析**

查找成功或不成功时，比较次数最多都为:
$$
\lfloor{log_2{n}}\rfloor + 1
$$
平均查找长度为:
$$
(\frac{n+1}{n} {log_2{(n+1)}}) - 1
$$
由此可见，二分查找的时间复杂度比顺序查找要好，但是相比而言，二分查找要求表元素是排好序的。非顺序表存储结构或顺序表元素未按键值排序（递增或递减）时，不能进行二分查找。



##### 3. 索引表上的查找 - 分块查找

> 首先建立索引表，将数据分块，把每块中最大（或最小）关键字及指针依次存入一张表中，此表称为索引表；
>
> 查找索引表，将预期关键字 k 与索引表中每块元素进行比较，确定预期查找元素所在块号；
>
> 在相应块中按顺序查找关键字为 k 的记录

平均查找长度为：
$$
\frac{1}{2}(\frac{n}{s}+s)+1
$$


##### 4. 算法分析

静态查找表的上述三种不同实现各有优缺点，其中：

- 顺序查找效率最低，但限制最少
- 二分查找效率最高，但限制最强
- 分块查找介于二者之间

实际应用中根据需要选择。



#### 动态查找

##### 1. 二叉排序树

又称二叉查找树，具有以下性质：

- 若左子树不空，则左子树上所有结点的键值均小于它的根结点键值；
- 若右子树不空，则右子树上所有结点的键值均大于它的根结点键值；
- 根的左、右子树也分别为二叉排序树。
- 空二叉树也是二叉排序树的一种。

**中序遍历**一颗二叉排序树所得的结点访问序列是键值的**递增**序列。

查找分析：二叉排序树的平均查找长度是介于 O(n) 和 O(log 以 2 为底 n 的对数) 之间，其查找效率与树的形态有关。

- 理想情况，树左右对称，每次在一半的元素里查找，时间复杂度为 O(log 以 2 为底 n 的对数)
- 最坏情况，单枝树（从大到小或从小到大），需要遍历树的全部元素，时间复杂度为 O(n)

平均查找长度为：sum(层数 * 该层结点数) / 总结点数



##### 2. 散列表（哈希表）

> 为了使数据元素的存储位置和键值之间建立某种联系，以减少比较次数，可以用散列技术实现动态查找表。

- 散列函数（哈希函数）决定关键字在表中地址，Addr(a) = H(k)

- 散列地址：由散列函数决定数据元素的存储位置，该位置称为散列地址
- 散列查找：给定关键字，通过散列函数转换，得到在表中的地址，如果查找到该元素则输出信息，反之将它填到此位置上
- 散列表：通过散列法建立的表称为散列表
- ==冲突==：不同的关键字映射到同一存储单元，这些关键字称为==同义词==



**常用散列法**

- 数字分析法：若一组数据前面 n 位都一样，则排除这些重复位
- ==除留余数法==：取关键字被某个数 p 除后所得余数作为散列地址，p 不取偶数，一般为最接近表长的==质数==
- 平方取中法：以键值平方的中间几位作为散列地址
- 基数转换法：转换进制，根据散列表的长度从中选取几位作为散列地址



**散列表解决冲突的方法**

- 线性探测法：取余作为表中地址，被占用后就往后移，超出表长就从头开始
- 二次探测法：取余作为表中地址，被占用后先加1的平方，还被占用就减1的平方，再被占用就加2的平方，直到有空位
- 链地址法：取余作为指针，指向所有取余后等于指针的键值链表，每个单链表都是一个同义词表
- 多重散列法：设立多个散列函数，优点是不易产生==堆积==
- 公共溢出区法：由两个一维数组组成，一个是散列表，一个是溢出表，同义词存入溢出表



